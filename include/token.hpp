#ifndef TOKEN_HPP
#define TOKEN_HPP

#include <string>
#include <variant>
#include <vector>
#include <utility> // For std::pair

// Enum for different token types
enum class TokenType {
    // Single-character tokens
    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
    LEFT_BRACKET, RIGHT_BRACKET,
    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR, PERCENT,
    PIPE, COLON,
    // BACKTICK, // Not needed as a separate token type

    // One or two character tokens
    BANG, BANG_EQUAL,
    EQUAL, EQUAL_EQUAL,
    GREATER, GREATER_EQUAL, // Comparison > >=
    LESS, LESS_EQUAL,       // Comparison < <=

    // Literals
    IDENTIFIER, STRING, NUMBER_INT, NUMBER_FLOAT,
    INTERPOLATED_STRING,

    // Keywords
    AND, CLASS, ELSE, FALSE, FN, FOR, IF, NIL, OR,
    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,
    MAP, DELETE,
    BREAK, CONTINUE,
    LIST,
    IMPORT, // <<< ADDED IMPORT keyword token type

    // Type Keywords
    INT, FLOAT, BOOL, STRING_TYPE, OBJ,
    FUNCTION,

    // Special
    END_OF_FILE,
    UNKNOWN // For errors
};

// Declaration for string conversion function
std::string tokenTypeToString(TokenType type);

// Helper types for interpolated string data
enum class InterpolationPartType {
    LITERAL,    // A literal string part
    EXPRESSION  // A part containing code to be evaluated (stored as string initially)
};
// A single part: its type and the raw string content
using InterpolatedPart = std::pair<InterpolationPartType, std::string>;
// The full data for an interpolated string token literal
using InterpolatedStringData = std::vector<InterpolatedPart>;


// Represents a token generated by the Lexer
// Using TokenLiteral = std::variant<...> for brevity
using TokenLiteral = std::variant<
    std::monostate,      // No literal
    std::string,         // For STRING literals
    int,                 // For NUMBER_INT
    double,              // For NUMBER_FLOAT
    bool,                // For TRUE/FALSE
    InterpolatedStringData // For INTERPOLATED_STRING
>;

struct Token {
    TokenType type;
    std::string lexeme; // The raw text of the token (e.g., `"hello"`, `myVar`, `` `Hello {n}` ``)
    TokenLiteral literal; // The literal value (if any).
    int line; // Line number where the token appears

    // Default constructor
    Token() : type(TokenType::UNKNOWN), lexeme(""), literal(std::monostate{}), line(-1) {}
    // Constructor with specific literal type
    Token(TokenType type, std::string lexeme, TokenLiteral literal_val, int line)
        : type(type), lexeme(std::move(lexeme)), literal(std::move(literal_val)), line(line) {}
    // Constructor without literal (uses monostate)
    Token(TokenType type, std::string lexeme, int line)
        : type(type), lexeme(std::move(lexeme)), literal(std::monostate{}), line(line) {}

    // Declaration for toString method
    std::string toString() const;
};

#endif // TOKEN_HPP
