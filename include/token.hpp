#ifndef TOKEN_HPP
#define TOKEN_HPP

#include <string>
#include <variant>
#include <vector>
#include <utility> // For std::pair

// Enum for different token types
enum class TokenType {
    // Single-character tokens
    LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
    LEFT_BRACKET, RIGHT_BRACKET,
    COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR, PERCENT,
    PIPE, COLON,
    // BACKTICK, // Not needed as a separate token type

    // One or two character tokens
    BANG, BANG_EQUAL,
    EQUAL, EQUAL_EQUAL,
    GREATER, GREATER_EQUAL, // Comparison > >=
    LESS, LESS_EQUAL,       // Comparison < <=

    // Literals
    IDENTIFIER, STRING, NUMBER_INT, NUMBER_FLOAT,
    INTERPOLATED_STRING, // <<< ADDED for `...` literals

    // Keywords
    AND, CLASS, ELSE, FALSE, FN, FOR, IF, NIL, OR,
    PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,
    MAP, DELETE,
    BREAK, CONTINUE,
    LIST,

    // Type Keywords
    INT, FLOAT, BOOL, STRING_TYPE, OBJ,
    FUNCTION,

    // Special
    END_OF_FILE,
    UNKNOWN // For errors
};

// Declaration for string conversion function
std::string tokenTypeToString(TokenType type);

// <<< ADDED: Helper types for interpolated string data >>>
enum class InterpolationPartType {
    LITERAL,    // A literal string part
    EXPRESSION  // A part containing code to be evaluated (stored as string initially)
};
// A single part: its type and the raw string content
using InterpolatedPart = std::pair<InterpolationPartType, std::string>;
// The full data for an interpolated string token literal
using InterpolatedStringData = std::vector<InterpolatedPart>;
// <<< END ADDED >>>

// Represents a token generated by the Lexer
struct Token {
    TokenType type;
    std::string lexeme; // The raw text of the token (e.g., `"hello"`, `myVar`, `` `Hello {n}` ``)
    // The literal value (if any). Now includes InterpolatedStringData.
    std::variant<
        std::monostate,      // No literal
        std::string,         // For STRING literals
        int,                 // For NUMBER_INT
        double,              // For NUMBER_FLOAT
        bool,                // For TRUE/FALSE
        InterpolatedStringData // <<< ADDED for INTERPOLATED_STRING
    > literal;
    int line; // Line number where the token appears

    // Default constructor
    Token() : type(TokenType::UNKNOWN), lexeme(""), literal(std::monostate{}), line(-1) {}
    // Constructor with specific literal type
    Token(TokenType type, std::string lexeme,
          std::variant<std::monostate, std::string, int, double, bool, InterpolatedStringData> literal_val, // Updated variant list
          int line)
        : type(type), lexeme(std::move(lexeme)), literal(std::move(literal_val)), line(line) {}
    // Constructor without literal (uses monostate)
    Token(TokenType type, std::string lexeme, int line)
        : type(type), lexeme(std::move(lexeme)), literal(std::monostate{}), line(line) {}

    // Declaration for toString method
    std::string toString() const;
};

#endif // TOKEN_HPP
